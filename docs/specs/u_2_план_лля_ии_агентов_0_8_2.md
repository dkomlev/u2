Ниже — обновлённая архитектура с учётом поправок и отдельный план работ для ИИ-агентов. Англицизмы заменены, сложные термины вынесены в глоссарий.

---

# 1. Назначение документа

Документ описывает:

* общую архитектуру прототипа космического онлайн-симулятора;
* поэтапный план разработки (этапы M0–M8);
* структуру работ для ИИ-агентов (автоматических разработчиков).

Документ адресован:

* архитекторам и программистам клиент-серверных приложений;
* техническим дизайнерам;
* ИИ-агентам, которым нужны чёткие задачи, входные и выходные данные и критерии готовности.

Во всех разделах делаем акцент на:

* прозрачное разделение обязанностей между модулями;
* детерминированность (одинаковый результат на клиенте и сервере);
* минимальную зависимость ранних этапов от сложных будущих систем.

---

# 2. Этапы M0–M8 (краткий обзор)

Этапы идут последовательно. Каждый следующий этап дополняет предыдущий, но не ломает уже зафиксированные интерфейсы.

| Этап | Суть этапа                                                                                  |
|------|---------------------------------------------------------------------------------------------|
| M0   | Каркас проекта, общая математика, простая физика по Ньютону, ядро компонентной системы.     |
| M1   | Серверная физика с релятивистской надстройкой, автономный клиент без сети.                 |
| M2   | Сетевой протокол, согласование клиента и сервера, предсказание на стороне клиента.         |
| M3   | Обработка управления, приоритеты источников, базовые режимы помощника пилота.              |
| M4   | Наблюдение с учётом задержки света, очередь событий «из будущего», расширенная телеметрия. |
| M5   | Расширенный помощник пилота («управляемый занос»), аварийные режимы и защита от ошибок.    |
| M6   | Базовый бой с вероятностью попадания, захват цели, простые противники-боты.                |
| M7   | Подробная модель нагрева и повреждений, распределение тяги по двигателям.                  |
| M8   | Оптимизация производительности и поддержка целевых платформ (ПК, браузер, мобильные).      |

---

# 3. Архитектура по этапам

## M0. Основа проекта

### 0.1. Структура проекта и сборка

**Цель.** Подготовить единый проект, в котором клиент, сервер и общая часть собираются и проверяются автоматически.

**Основная структура**

* `shared/` — общая библиотека:
  * векторная математика;
  * простая физика по Ньютону;
  * базовые описания объектов и сообщений.
* `server/` — сервер симуляции на платформе .NET 8 без графики.
* `client/` — клиент на игровом движке Unity (двухмерный режим отображения).

**Важно**

* Настраиваются автоматические сборки и запуск тестов при каждом изменении.
* Вводятся единые правила оформления кода и проверка этих правил.

### 0.2. Общая математика и поле скорости света

**Цель.** Ввести общую математическую библиотеку и заготовку для поля локальной скорости света.

**Что делаем**

* Реализуем операции над векторами: сложение, вычитание, длина, нормализация, скалярное произведение.
* Вводим простые численные фильтры для сглаживания резких изменений (например, для управления).
* Вводим понятие поля локальной скорости света:
  * в каждой точке мира задаётся значение «эффективной» скорости света;
  * на этапе M0 поле используется как таблица значений для интерфейса (панель приборов), но ещё не включено в физику.
* Задаём режимы работы поля:
  * статический режим — значение зависит только от координат;
  * адаптивный режим по нагрузке оставляем на будущее (этап M4 и далее), сейчас он только зарезервирован.

### 0.3. Простое ядро компонентной системы

**Цель.** Описать объекты мира через набор простых компонент и обеспечить единый цикл обновления.

**Что делаем**

* Вводим базовые компоненты:
  * положение и ориентация;
  * скорость;
  * масса;
  * простой набор параметров корабля (силовая установка, нагрев).
* Вводим системы (обработчики), которые:
  * поочерёдно проходят по объектам;
  * обновляют компоненты по шагу времени.
* Обеспечиваем сохранение и восстановление состояния мира (для последующей пересылки по сети и сохранения).

---

## M1. Физика и автономный клиент

### 1.1. Серверная физика: от классики к релятивистской модели

**Цель.** Реализовать серверный расчёт движения кораблей и включить релятивистские эффекты как настраиваемое расширение.

**Что делаем**

* На уровне конфигурации вводим два режима:
  * классический режим — расчёт по законам Ньютона;
  * расширенный режим — добавляются релятивистские поправки.
* В расширенном режиме:
  * вводится коэффициент Лоренца (γ), который растёт при приближении скорости к скорости света;
  * сила раскладывается на продольную (вдоль движения) и поперечную (поперёк движения) части;
  * учитывается ограничение: скорость всегда меньше локальной скорости света.
* Все вычисления выполняются в общей библиотеке `shared/`, чтобы клиент и сервер использовали одно и то же.

**Критерии готовности**

* При отключённой релятивистской надстройке поведение совпадает с результатами M0.
* При включённой надстройке выполняются инварианты:
  * скорость меньше выбранной доли от локальной скорости света;
  * коэффициент Лоренца всегда не меньше единицы;
  * не возникает переполнений чисел.

### 1.2. Автономный клиент: простая карта и панель приборов

**Цель.** Позволить запускать симуляцию локально, без сети, чтобы видеть движение корабля и проверять физику.

**Что делаем**

* Создаём простую двухмерную сцену:
  * фон с условной сеткой;
  * изображение корабля;
  * несколько неподвижных объектов (например, диски-астероиды).
* Добавляем панель приборов:
  * текущая скорость;
  * отношение скорости к локальной скорости света;
  * коэффициент Лоренца (если релятивистский режим включён);
  * температура и ограничение по тяге.

---

## M2. Сеть и согласование клиента и сервера

### 2.1. Формат сообщений и транспорт

**Цель.** Описать, какие данные и как передаются между клиентом и сервером.

**Что делаем**

* Вводим несколько основных типов сообщений:
  * команды управления от клиента к серверу;
  * подтверждения и снимки состояния от сервера к клиенту;
  * события (например, попадания в бою).
* Для компьютеров и мобильных устройств используем протокол передачи датаграмм (быстрая, но не гарантированная доставка).
* Для браузера используется протокол постоянного соединения (сообщения по открытому каналу).

**Критерии готовности**

* Любое сообщение можно преобразовать в поток байтов и обратно без потерь.
* Версии сообщений и расширения описаны так, чтобы старые клиенты не ломались при добавлении новых полей.

### 2.2. Предсказание на клиенте и пересчёт

**Цель.** Сделать управление плавным, несмотря на задержки связи.

**Что делаем**

* Сервер выполняет вычисления с фиксированной частотой (например, 30 раз в секунду).
* Клиент:
  * отправляет команды с той же частотой;
  * ведёт историю отправленных команд;
  * после получения ответа от сервера пересчитывает своё состояние вперёд (до текущего момента) и мягко подстраивает картинку.
* Разница между состоянием сервера и клиентским предсказанием показывается только визуально, без резких скачков.

---

## M3. Управление и базовые режимы помощника пилота

### 3.1. Источники управления и их приоритеты

**Цель.** Упорядочить все возможные источники команд, чтобы они не конфликтовали.

**Источники управления**

* локальный игрок (клавиатура, мышь, геймпад, виртуальные джойстики);
* удалённый оператор (например, для обучения или сопровождения);
* автопилот.

**Приоритеты**

* Наивысший приоритет — локальный игрок.
* Далее — удалённый оператор.
* После них — автопилот.

Ассистент пилота не является отдельным источником команд. Он работает поверх выбранного источника: получает его команды и преобразует в более безопасные и плавные сигналы.

**Дополнительно**

* Для каждой оси управления (поворот, тяга вперёд/назад, боковое смещение) в каждый момент времени действует только один источник.
* При переключении источников по оси делается плавный переход (порядка 150–200 миллисекунд), чтобы не было резкого скачка тяги.

### 3.2. Базовые режимы помощника пилота

**Цель.** Помочь игроку управлять кораблём так, чтобы он не терял контроль и не испытывал резких перегрузок.

**Режимы**

1. **Стабилизированный режим (режим по умолчанию).**  
   Система:
   * уменьшает неконтролируемое вращение;
   * ограничивает резко меняющиеся ускорения;
   * плавно гасит небольшие колебания.
2. **Свободный режим.**  
   Команды игрока идут почти напрямую, с минимумом ограничений. Используется для опытных игроков и сложных манёвров.

В обоих режимах ассистент:

* не меняет назначение органов управления;
* только ограничивает ускорения, угловые скорости и воздействие на двигатели, исходя из настроек корабля.

---

## M4. Наблюдение с задержкой света и расширенная телеметрия

### 4.1. Наблюдение с учётом задержки света

**Цель.** Использовать задержку распространения света по игровому миру для маскировки сетевых задержек и повышения плавности.

**Что делаем**

* Для каждого объекта сервер рассчитывает время, за которое свет от него долетает до наблюдателя.  
  Это расстояние, делённое на локальную скорость света в этой области.
* Сервер отправляет клиенту состояние объектов, помеченное временем, которое соответствует моменту «по свету».
* Клиент:
  * складывает эти сообщения в очередь;
  * показывает их не сразу, а в рассчитанный момент, учитывая сетевую задержку и задержку света.

На этапе M4 поле скорости света работает в статическом режиме. Адаптивный режим (подстройка под нагрузку) включается позже и не меняет уже существующие интерфейсы.

### 4.2. Дополнительная панель приборов и телеметрия

**Цель.** Сделать сетевые эффекты и работу ассистента прозрачными для пилота и удобными для отладки.

**Новые элементы панели**

* текущий режим ассистента;
* доля влияния ассистента на управление;
* активный источник управления по каждой оси;
* средняя задержка связи и разброс задержки;
* глубина очереди событий «из будущего» (на сколько миллисекунд вперёд показываются объекты).

Эти данные читают только интерфейсы и отладочные инструменты. Основная физика от них не зависит.

---

## M5. Расширенный помощник пилота и аварийные режимы

### 5.1. Режим «управляемый занос»

**Цель.** Добавить продвинутый режим помощи, при котором корабль ведёт себя как спортивный автомобиль в контролируемом заносе.

**Особенности**

* Пилот задаёт желаемые ускорения и направление, а система:
  * ведёт нос корабля по оптимальной дуге;
  * контролирует скольжение поперёк направления движения;
  * ограничивает изменения ускорений во времени, чтобы не было резких рывков.
* Настройки зависят от типа корабля:
  * лёгкий истребитель — быстрые реакции;
  * грузовой корабль — плавные дуги;
  * тяжёлые суда — инерционность и мягкость.

Подробные требования к этому режиму и его приёмочные сценарии оформляются в отдельном техническом задании для модуля «помощник пилота».

### 5.2. Аварийные режимы и защита от ошибок

**Цель.** Предотвратить потерю контроля над кораблём и критические перегрузки.

**Что делаем**

* Вводим пороговые значения:
  * слишком высокая угловая скорость;
  * слишком сильное скольжение;
  * превышение допустимых перегрузок для пилотируемого корабля;
  * опасная близость к препятствиям.
* При превышении порогов ассистент временно усиливает влияние:
  * выравнивает курс;
  * снижает скорость;
  * выстраивает безопасную траекторию.
* После выхода из опасной зоны влияние ассистента плавно возвращается к обычному уровню.

---

## M6. Базовый бой и боты

### 6.1. Бой с захватом цели и вероятностью попадания

**Цель.** Ввести простую боевую модель без просчёта траекторий каждого снаряда.

**Что делаем**

* Игрок выбирает цель, сервер хранит, кто в кого целится.
* При выстреле сервер рассчитывает вероятность попадания по формуле, зависящей от:
  * калибра оружия;
  * расстояния до цели;
  * размера цели;
  * относительной скорости;
  * релятивистских эффектов (если включены).

**Пример формулы**

Вероятность попадания лежит в диапазоне от 0 до 1 и определяется как произведение нескольких множителей, каждый из которых отвечает за один фактор (расстояние, скорость, размер цели и т. д.).  
При слишком большой дальности или слишком высокой относительной скорости вероятность уменьшается до малых значений.

**Критерии готовности**

* При «удобной» дистанции и не слишком больших относительных скоростях вероятность попадания находится, например, в диапазоне 50–80 %.
* При увеличении расстояния или резком росте относительной скорости вероятность плавно уменьшается.

### 6.2. Простые боты

**Цель.** Наполнить мир противниками и союзниками, не усложняя архитектуру.

**Что делаем**

* Боты используют те же механизмы, что и игроки:
  * те же помощники пилота;
  * те же ограничения по тяге, ускорениям и задержке света.
* Реализуем простые сценарии:
  * патрулирование;
  * преследование;
  * попытка уйти от преследователя.

---

## M7. Нагрев, повреждения и распределение тяги

### 7.1. Нагрев и повреждения

**Цель.** Сделать поведение корабля под нагрузкой более правдоподобным.

**Что делаем**

* Каждая подсистема имеет:
  * диапазон рабочих температур;
  * допустимые перегрузки.
* При приближении к пределу:
  * тяга урезается;
  * включаются защитные режимы;
  * возможны частичные отказы.

Модель построена так, чтобы можно было настраивать её через параметры корабля, не переписывая код.

### 7.2. Распределение тяги по двигателям

**Цель.** Перевести «идеальные» команды ассистента в нагрузки на реальные двигатели.

**Что делаем**

* На входе модуль получает:
  * требуемые силы и моменты;
  * список двигателей с их положением и состоянием.
* На выходе:
  * набор команд для каждого двигателя;
  * сообщение, если требуемая команда физически невыполнима (например, слишком большой момент).

---

## M8. Оптимизация и платформы

### 8.1. Оптимизация

**Цель.** Обеспечить устойчивую работу на целевых устройствах.

**Что делаем**

* Уменьшаем лишние выделения памяти.
* Объединяем повторяющиеся операции отрисовки.
* Ищем «узкие места» в симуляции и пересматриваем их реализацию.

### 8.2. Платформенные сборки

**Цель.** Получить рабочие сборки для:

* персональных компьютеров;
* браузера;
* мобильных устройств.

Для каждой платформы:

* настраивается схема управления;
* подбирается уровень качества графики;
* выбирается подходящий сетевой транспорт (датаграммы или постоянное соединение).

---

# 4. Сквозные требования к архитектуре

1. **Фиксация интерфейсов по этапам.**  
   После завершения этапа интерфейсы считаются замороженными. В дальнейшем можно только добавлять новые поля и настройки, не ломая существующие.

2. **Детерминизм.**  
   Любой код, который выполняется и на клиенте, и на сервере, должен при одинаковых входных данных выдавать один и тот же результат.

3. **Тесты до интерфейса.**  
   Прежде чем выводить новый функционал в пользовательский интерфейс, должны быть готовы модульные и интеграционные тесты ядра.

4. **Отладка — часть готовности.**  
   Для каждого этапа должны быть:
   * счётчики задержек;
   * журналы событий;
   * отладочные элементы панели приборов.

5. **Возможность отключения новых функций.**  
   Сложные режимы (релятивистская надстройка, адаптивное поле скорости света, режим «управляемого заноса») включаются через настройки и по умолчанию могут быть выключены на ранних этапах.

---

# 5. План работ для ИИ-агентов

Ниже — укрупнённый план задач для ИИ-агентов. Для каждого пункта предполагается:

* входные данные (описание требований к модулю);
* ожидаемый результат (код, конфигурации, тесты);
* критерии готовности (какие тесты должны проходить, какие проверки выполнить вручную).

## M0

1. **Агент «Структура проекта»**
   * Создать структуру директорий `shared/`, `server/`, `client/`.
   * Настроить автоматическую сборку и запуск тестов.
2. **Агент «Математика»**
   * Реализовать базовые операции над векторами.
   * Добавить простые фильтры для сглаживания сигналов.
3. **Агент «Поле скорости света»**
   * Реализовать статическое поле скорости света, зависящее от координат.
   * Написать тесты на плавность переходов.
4. **Агент «Компонентная система»**
   * Ввести компоненты положения, скорости, массы и силовой установки.
   * Реализовать сохранение и восстановление состояния мира.

## M1

1. **Агент «Физика сервера»**
   * Реализовать классический расчёт движения по Ньютону.
   * Добавить переключаемую релятивистскую надстройку.
   * Написать тесты, проверяющие инварианты (скорость меньше скорости света и т. д.).
2. **Агент «Автономный клиент»**
   * Создать простую сцену с кораблём и объектами.
   * Реализовать панель приборов с выводом скорости, отношения к скорости света и температуры.

## M2

1. **Агент «Формат сообщений»**
   * Описать основные типы сообщений.
   * Обеспечить сериализацию и обратное преобразование без потерь.
2. **Агент «Клиентское предсказание»**
   * Реализовать хранение истории команд.
   * Настроить пересчёт состояния после прихода ответов от сервера.
   * Сделать плавное подстраивание визуального состояния.

## M3

1. **Агент «Обработка управления»**
   * Реализовать учёт всех источников управления.
   * Ввести приоритеты: локальный игрок ≥ удалённый оператор ≥ автопилот.
   * Написать тесты на плавное переключение источников.
2. **Агент «Базовые режимы ассистента»**
   * Реализовать стабилизированный и свободный режимы.
   * Добавить настройки коэффициентов в конфигурации.

## M4

1. **Агент «Наблюдение с задержкой света»**
   * Реализовать расчёт времени пролёта света.
   * Реализовать очередь событий «из будущего» на клиенте.
2. **Агент «Телеметрия»**
   * Добавить показатели задержки, разброса задержек, глубины очереди.
   * Подготовить отладочную панель для разработчиков.

## M5

1. **Агент «Режим управляемого заноса»**
   * Реализовать расширенный режим помощника пилота по техническому заданию.
   * Обеспечить разные настройки для разных типов кораблей.
2. **Агент «Аварийные режимы»**
   * Ввести пороги срабатывания.
   * Написать тесты и сценарии, проверяющие выход из опасной зоны.

## M6

1. **Агент «Боевая модель»**
   * Реализовать захват цели.
   * Реализовать расчёт вероятности попадания на сервере.
2. **Агент «Боты»**
   * Реализовать простые сценарии поведения.
   * Настроить использование теми же помощниками пилота и ограничениями, что у игрока.

## M7

1. **Агент «Нагрев и повреждения»**
   * Реализовать расширенную модель нагрева.
   * Ввести отказы подсистем при перегреве.
2. **Агент «Распределение тяги»**
   * Реализовать перевод силы и момента в команды для отдельных двигателей.
   * Написать тесты на достижимость команд и поведение при отказах.

## M8

1. **Агент «Оптимизация»**
   * Собрать данные о производительности.
   * Переписать проблемные места.
2. **Агент «Платформенные сборки»**
   * Настроить управление и графику под каждую платформу.
   * Проверить сетевое поведение на целевых устройствах.

---

# 6. Глоссарий

* **Ассистент пилота** — модуль, который помогает игроку управлять кораблём, сглаживает команды и ограничивает опасные режимы.
* **Автопилот** — программа, которая самостоятельно управляет кораблём по заданным целям.
* **Время пролёта света** — время, за которое свет проходит расстояние от объекта до наблюдателя.
* **Детерминизм** — свойство системы давать один и тот же результат при одинаковых входных данных.
* **Инвариант** — условие, которое всегда должно быть выполнено (например, скорость меньше скорости света).
* **Компонентная система** — способ описания объектов через набор простых частей (компонент), каждая отвечает за один аспект (положение, физика, управление).
* **Коэффициент Лоренца (γ)** — множитель, отражающий релятивистские эффекты при высоких скоростях.
* **Локальная скорость света** — скорость распространения света в выбранной точке игрового мира, может отличаться от «обычной» скорости света в вакууме.
* **Ньютоновская физика** — классическое описание движения без релятивистских эффектов.
* **Отладочная панель** — набор экранных элементов, показывающих внутренние параметры (скорость, задержку связи, влияние ассистента и т. д.).
* **Панель приборов** — основная часть интерфейса, где игрок видит ключевые параметры корабля.
* **Релятивистская физика** — физика, учитывающая эффекты при скоростях, близких к скорости света.
* **Сетевой протокол** — набор правил, по которым клиент и сервер обмениваются данными.
* **Снимок состояния** — набор данных, описывающий мир в конкретный момент времени.
* **Телеметрия** — служебные данные о работе системы (задержки, частоты вызовов, нагрузка), которые используются для анализа и отладки.
* **Этап M0–M8** — логические шаги развития проекта. Каждый следующий этап расширяет систему, но не ломает уже зафиксированные интерфейсы и поведение.

